#' Identify defoliation events as growth surges in a host series
#'
#' @param input_series a data frame with 5 columns, as generated by \code{gsi}.
#'
#' @param duration_years the minimum length of time in which the tree is
#'   considered to be in defoliation
#'
#' @param max_surge minimum value of ngsi required to be considered an
#'   event. If a sequence of possitive ngsi values does not reach this threshold,
#'   the potential event is rejected. Defaults to 1.28 (sd units).
#'
#' @param bridge_events Binary, defaults to \code{FALSE}. This option allows for
#'   successive events that are separated by a single year to be bridged and become one
#'   event. It should be used cautiously and closely evaluated to ensure the
#'   likelihood that the two (or more) events are actually one long event.
#'
#' @param series_end_event Binary, defaults to \code{FALSE}. This option allows
#'   the user to identify an event ocuring at the time of sampling as a
#'   defoliation event, regardless of duration. Including it will help to
#'   quantify periodicity and extent of an outbreak. This should only be used if
#'   the user has direct knowledge of an ongoing defoliation event when the
#'   trees were sampled.
#'
#' @return after performing runs analyses, the function adds a column to the
#'   input data frame that distinguishes years of defoliation and the maximum
#'   defoliation year (ie. the year the greatest negative growth departure
#'   within the event).
#'
#' @export
id_defoliation <- function(input_series, duration_years = 8, max_surge = 1.28, bridge_events = FALSE, series_end_event = FALSE){
  rns <- rle(as.vector(input_series[, 5] > 0))
  rns.index = cumsum(rns$lengths)
  neg.runs.pos <- which(rns$values == TRUE)
  ends <- rns.index[neg.runs.pos]
  newindex = ifelse(neg.runs.pos > 1, neg.runs.pos - 1, 0)
  starts <- rns.index[newindex] + 1
  if (0 %in% newindex) starts = c(1,starts)
  deps <- data.frame(cbind(starts, ends))
  input_series$defol_status = NA
  events <- c("defol", "max_defol", "bridge_defol", "series_end_defol")
  for(y in 1:nrow(deps)){
    dep.seq <- deps$starts[y] : deps$ends[y]
    if(any(input_series[dep.seq, ]$defol_status %in% events)) next
    if((! bridge_events) & (y > 1)){
      if(any(input_series[min(dep.seq) - 2, ] %in% events)) next
    }
    max.red <- dep.seq[1] + which.max(input_series[dep.seq, 5]) - 1
    if(input_series[max.red, 5] < max_surge) next  # Includes setting for max growth reduction

    prev.flag <- FALSE
    if(y > 1){
      if(min(dep.seq) - deps$ends[y - 1] == 2) {
        if(! any(input_series[deps$starts[y - 1] : deps$ends[y - 1], ]$defol_status  %in% events)){
          dep.seq <- c(deps$starts[y - 1] : max(dep.seq))
          prev.flag <- TRUE
        }
      }
    }
    if(y < nrow(deps)){
      if(deps$starts[y + 1] - max(dep.seq) == 2){
        if(min(input_series[dep.seq, 5]) > min(input_series[deps$starts[y + 1] : deps$ends[y + 1], 5]))  next
        if((! prev.flag) & (y < nrow(deps) - 1)){
          if(deps$starts[y + 2] - deps$ends[y + 1] == 2){
            if(min(input_series[dep.seq, 5]) > min(input_series[deps$starts[y + 2] : deps$ends[y + 2], 5]))  next
          }
        }
        dep.seq <- c(min(dep.seq) : deps$ends[y + 1])
      }
    }
    if(series_end_event){
      if(any((deps[y, 'ends'] - nrow(input_series)) == c(0:2))){
        dep.seq <- c(min(dep.seq) : nrow(input_series))
      }
    }
    if(!(y == nrow(deps) & series_end_event)){
      if(length(dep.seq) < duration_years) next # Includes setting for min duration
    }
    input_series[dep.seq, "defol_status"] <- "defol"
    input_series[max.red, "defol_status"] <- "max_defol"
    if(nrow(input_series) == max(dep.seq)){
      input_series[dep.seq, ]$defol_status <- replace(input_series[dep.seq, ]$defol_status,
                                                      input_series[dep.seq, ]$defol_status == "defol",
                                                      "series_end_defol")
    }
    if(y > 1 & bridge_events){
      if(any(input_series[min(dep.seq) - 2, ]$defol_status %in% events)){
        input_series[min(dep.seq) - 1, "defol_status"] <- "bridge_defol"
      }
    }
  }
  input_series$defol_status <- replace(input_series$defol_status,
                                       is.na(input_series$defol_status),
                                       "nd")
  return(input_series)
}

